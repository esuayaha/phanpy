import { Decimal } from 'decimal.js';
import { invariant } from '../utils.js';
import { getPowerOf10 } from './decimal-cache.js';
Decimal.set({
    toExpPos: 100,
});
/**
 * The abstract operation ComputeExponentForMagnitude computes an exponent by which to scale a
 * number of the given magnitude (power of ten of the most significant digit) according to the
 * locale and the desired notation (scientific, engineering, or compact).
 */
export function ComputeExponentForMagnitude(internalSlots, magnitude) {
    var notation = internalSlots.notation, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;
    switch (notation) {
        case 'standard':
            return 0;
        case 'scientific':
            return magnitude.toNumber();
        case 'engineering':
            var thousands = magnitude.div(3).floor();
            return thousands.times(3).toNumber();
        default: {
            invariant(notation === 'compact', 'Invalid notation');
            // Let exponent be an implementation- and locale-dependent (ILD) integer by which to scale a
            // number of the given magnitude in compact notation for the current locale.
            var compactDisplay = internalSlots.compactDisplay, style = internalSlots.style, currencyDisplay = internalSlots.currencyDisplay;
            var thresholdMap = void 0;
            if (style === 'currency' && currencyDisplay !== 'name') {
                var currency = dataLocaleData.numbers.currency[numberingSystem] ||
                    dataLocaleData.numbers.currency[dataLocaleData.numbers.nu[0]];
                thresholdMap = currency.short;
            }
            else {
                var decimal = dataLocaleData.numbers.decimal[numberingSystem] ||
                    dataLocaleData.numbers.decimal[dataLocaleData.numbers.nu[0]];
                thresholdMap = compactDisplay === 'long' ? decimal.long : decimal.short;
            }
            if (!thresholdMap) {
                return 0;
            }
            var num = getPowerOf10(magnitude).toString();
            var thresholds = Object.keys(thresholdMap); // TODO: this can be pre-processed
            if (num < thresholds[0]) {
                return 0;
            }
            if (num > thresholds[thresholds.length - 1]) {
                // GH #4236: When number exceeds max threshold, use the exponent
                // corresponding to the largest available threshold in locale data.
                // Calculate exponent the same way as for normal thresholds (lines 70-73).
                var magnitudeKey_1 = thresholds[thresholds.length - 1];
                var compactPattern_1 = thresholdMap[magnitudeKey_1].other;
                if (compactPattern_1 === '0') {
                    return 0;
                }
                return (magnitudeKey_1.length -
                    thresholdMap[magnitudeKey_1].other.match(/0+/)[0].length);
            }
            var i = thresholds.indexOf(num);
            if (i === -1) {
                return 0;
            }
            // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
            // Special handling if the pattern is precisely `0`.
            var magnitudeKey = thresholds[i];
            // TODO: do we need to handle plural here?
            var compactPattern = thresholdMap[magnitudeKey].other;
            if (compactPattern === '0') {
                return 0;
            }
            // Example: in zh-TW, `10000000` maps to `0000Ëê¨`. So we need to return 8 - 4 = 4 here.
            return (magnitudeKey.length -
                thresholdMap[magnitudeKey].other.match(/0+/)[0].length);
        }
    }
}
