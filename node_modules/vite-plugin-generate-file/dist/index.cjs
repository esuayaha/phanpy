'use strict';

const fs = require('node:fs');
const path = require('node:path');
const node_buffer = require('node:buffer');
const pc = require('picocolors');
const yaml = require('js-yaml');
const ejs = require('ejs');
const mime = require('mime-types');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const pc__default = /*#__PURE__*/_interopDefaultCompat(pc);
const yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);
const ejs__default = /*#__PURE__*/_interopDefaultCompat(ejs);
const mime__namespace = /*#__PURE__*/_interopNamespaceCompat(mime);

function ensureDirectoryExistence(filePath) {
  const dirname = path__default.dirname(filePath);
  if (fs__default.existsSync(dirname)) {
    return;
  }
  ensureDirectoryExistence(dirname);
  fs__default.mkdirSync(dirname);
}
function trimBasePath(filename, base) {
  if (!base || base === "/") {
    return filename;
  }
  const basePath = `${path__default.resolve(base)}/`;
  if (filename.startsWith(basePath)) {
    return filename.slice(basePath.length - 1);
  }
  return filename;
}

const listTemplate = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Generate File List</title>\n<body>\n<h1>Generate File List</h1>\n<div>\n    <ul>\n        <% Object.keys(generateFiles).forEach(key => { %>\n            <li><a href='<%= key %>'><%= generateFiles[key].output %></a></li>\n        <% }) %>\n    </ul>\n</div>\n</body>\n</html>\n";

let config;
let distPath;
const generateFileMap = /* @__PURE__ */ new Map();
function normalizeOption(option) {
  const generateFileOption = {
    output: "./output.txt",
    type: "json",
    template: "",
    ...option
  };
  const fullPath = path.resolve(distPath, generateFileOption.output);
  const relativePath = `/${path.relative(distPath, fullPath)}`;
  const contentType = generateFileOption.contentType || mime__namespace.lookup(generateFileOption.output || "") || "text/plain";
  return {
    ...generateFileOption,
    contentType,
    fullPath,
    relativePath
  };
}
function generateContent(option) {
  if (!option.type) {
    return node_buffer.Buffer.from("", "utf-8");
  }
  if (option.type === "json") {
    if (option.data) {
      return node_buffer.Buffer.from(JSON.stringify(option.data), "utf-8");
    }
    return node_buffer.Buffer.from("", "utf-8");
  }
  if (option.type === "yaml") {
    if (option.data) {
      return node_buffer.Buffer.from(yaml__default.dump(option.data), "utf-8");
    }
    return node_buffer.Buffer.from("", "utf-8");
  }
  if (option.type === "template") {
    const templatePath = path.resolve(config.root, option.template);
    const templateContent = fs.readFileSync(templatePath, { encoding: "utf8" });
    return node_buffer.Buffer.from(ejs__default.render(templateContent, typeof option.data === "object" && option.data !== null ? option.data : {}), "utf-8");
  }
  if (option.type === "raw") {
    if (option.data) {
      if (node_buffer.Buffer.isBuffer(option.data)) {
        return option.data;
      }
      if (typeof option.data === "string") {
        return node_buffer.Buffer.from(option.data, "utf-8");
      }
    }
    return node_buffer.Buffer.from("", "utf-8");
  }
  console.warn(`Unknown type [${option.type}]`);
  return node_buffer.Buffer.from("", "utf-8");
}
function generateFile(option) {
  const filePath = option.fullPath;
  const fileContent = generateContent(option);
  ensureDirectoryExistence(filePath);
  fs.writeFileSync(filePath, fileContent, { flag: "w" });
  console.log(`Generate File to ${pc__default.green(filePath)}`);
}
function configureServer(server) {
  server.middlewares.use("/__generate_file_list", (req, res) => {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.write(
      ejs__default.render(listTemplate, {
        generateFiles: Object.fromEntries(generateFileMap)
      })
    );
    res.end();
  });
  server.middlewares.use((req, res, next) => {
    const uri = new URL(req.originalUrl, `http://${req.headers.host}`);
    const pathname = uri.pathname;
    const base = server.config.base || "/";
    const trimmedPathname = trimBasePath(pathname, base);
    if (generateFileMap.has(pathname) || generateFileMap.has(trimmedPathname)) {
      const option = generateFileMap.get(pathname) || generateFileMap.get(trimmedPathname);
      const content = generateContent(option);
      res.writeHead(200, {
        "Content-Type": option.contentType
      });
      res.write(content);
      res.end();
    } else {
      next();
    }
  });
  const _print = server.printUrls;
  server.printUrls = () => {
    let host = `${config.server.https ? "https" : "http"}://localhost:${config.server.port || "80"}`;
    const url = server.resolvedUrls?.local[0];
    if (url) {
      try {
        const u = new URL(url);
        host = `${u.protocol}//${u.host}`;
      } catch (error) {
        console.warn("Parse resolved url failed:", error);
      }
    }
    _print();
    const colorUrl = (url2) => pc__default.green(url2.replace(/:(\d+)\//, (_, port) => `:${pc__default.bold(port)}/`));
    console.log(
      `  ${pc__default.green("\u279C")}  ${pc__default.bold("Generate File List")}: ${colorUrl(
        `${host}/__generate_file_list/`
      )}`
    );
  };
}
function PluginGenerateFile(options) {
  return {
    name: "vite-plugin-generate-file",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      distPath = path.resolve(config.root, config.build.outDir);
      if (Array.isArray(options)) {
        options.forEach((option) => {
          const simpleOption = normalizeOption(option);
          generateFileMap.set(simpleOption.relativePath, simpleOption);
        });
      } else {
        const simpleOption = normalizeOption(options);
        generateFileMap.set(simpleOption.relativePath, simpleOption);
      }
    },
    closeBundle() {
      if (config.command === "serve") {
        return;
      }
      for (const option of generateFileMap.values()) {
        generateFile(option);
      }
    },
    configureServer
  };
}

module.exports = PluginGenerateFile;
